extends CharacterBody2D

# Movimento
const SPEED = 200.0
const JUMP_VELOCITY = -300.0

# Escava칞칚o
var is_digging = false
var dig_target_pos: Vector2i
var dig_progress: float = 0.0

# Refer칡ncias
@onready var dig_timer = $DigTimer
@onready var dig_indicator = $DigIndicator
@onready var game_manager = get_node("../../GameManager")
@onready var terrain_manager = get_node("../TerrainManager")

# Get the gravity from the project settings to be synced with RigidBody nodes
var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")

func _ready():
	# Configurar para funcionar sempre (necess치rio para movimento e escava칞칚o)
	process_mode = Node.PROCESS_MODE_ALWAYS
	
	# Debug: imprimir informa칞칫es iniciais
	print("Player iniciado na posi칞칚o: ", global_position)
	print("Gravity: ", gravity)

func _physics_process(delta):
	handle_gravity(delta)
	handle_movement()
	handle_digging()
	move_and_slide()

func handle_gravity(delta):
	# Aplicar gravidade se n칚o estiver no ch칚o
	if not is_on_floor():
		velocity.y += gravity * delta
		# Debug reduzido: s칩 mostrar quando cai muito
		if velocity.y > 200:  # Apenas quando cai muito r치pido
			var player_tile_pos = terrain_manager.world_to_tile_pos(global_position)
			print("Player caindo r치pido em tile: ", player_tile_pos, " | Vel Y: ", velocity.y)
	else:
		# Zerar velocidade vertical quando no ch칚o
		if velocity.y > 0:  # S칩 zerar se estava caindo
			velocity.y = 0

func handle_movement():
	# Pular
	if Input.is_action_just_pressed("ui_accept") and is_on_floor():
		velocity.y = JUMP_VELOCITY
	
	# Movimento horizontal
	var direction = Input.get_axis("ui_left", "ui_right")
	if direction:
		velocity.x = direction * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)

func handle_digging():
	# Verificar se est치 tentando cavar
	if Input.is_action_pressed("dig"):
		try_dig()
	elif Input.is_action_just_released("dig"):
		stop_digging()

func try_dig():
	# Determinar posi칞칚o de escava칞칚o baseada na posi칞칚o do mouse
	var mouse_pos = get_global_mouse_position()
	var target_tile_pos = terrain_manager.world_to_tile_pos(mouse_pos)
	var player_tile_pos = terrain_manager.world_to_tile_pos(global_position)
	
	# Verificar se o tile alvo est치 pr칩ximo do player (dist칙ncia m치xima de 2 tiles)
	var distance = player_tile_pos.distance_to(Vector2(target_tile_pos))
	if distance > 2.0:  # Dist칙ncia m치xima de 2 tiles
		stop_digging()
		return
	
	# Verificar se h치 um bloco para cavar
	if not terrain_manager.has_block_at(target_tile_pos):
		stop_digging()
		return
	
	# Verificar se o bloco pode ser escavado (n칚o grama)
	if not terrain_manager.can_dig_at(target_tile_pos):
		stop_digging()
		return
	
	# Se j치 est치 cavando este bloco, continuar
	if is_digging and dig_target_pos == target_tile_pos:
		return
	
	# Come칞ar a cavar novo bloco
	start_digging(target_tile_pos)

func start_digging(target_pos: Vector2i):
	# Debug reduzido
	is_digging = true
	dig_target_pos = target_pos
	dig_progress = 0.0
	
	# Configurar timer baseado na dificuldade e upgrades
	var base_dig_time = terrain_manager.get_dig_difficulty(target_pos)
	var dig_speed_multiplier = game_manager.get_dig_speed()
	var actual_dig_time = base_dig_time / dig_speed_multiplier
	
	# Garantir que o tempo seja sempre v치lido
	if actual_dig_time <= 0:
		actual_dig_time = 0.1  # M칤nimo de 0.1 segundos
	
	dig_timer.process_mode = Node.PROCESS_MODE_ALWAYS
	dig_timer.wait_time = actual_dig_time
	dig_timer.start()
	print("Timer iniciado com tempo: ", actual_dig_time)
	
	# Mostrar indicador visual
	dig_indicator.visible = true
	update_dig_indicator()

func stop_digging():
	is_digging = false
	dig_timer.stop()
	dig_indicator.visible = false
	dig_progress = 0.0

func update_dig_indicator():
	if not is_digging:
		return
	
	# Atualizar posi칞칚o do indicador para o tile alvo
	var target_world_pos = terrain_manager.map_to_local(dig_target_pos)
	dig_indicator.global_position = target_world_pos

func _on_dig_timer_timeout():
	if is_digging:
		complete_dig()

func complete_dig():
	# Realizar a escava칞칚o
	var dig_result = terrain_manager.dig_block(dig_target_pos)
	
	if dig_result.success:
		# Se encontrou ouro, adicionar ao invent치rio
		if dig_result.has_gold:
			var gold_collected = game_manager.add_gold(1)
			if gold_collected:
				print("游눯 Ouro coletado!")
		
		# For칞ar atualiza칞칚o da f칤sica ap칩s escavar
		await get_tree().process_frame
		
		# Debug: verificar se player deveria cair
		if not is_on_floor():
			print("Player deveria cair ap칩s escava칞칚o")
		
		# Verificar se est치 na superf칤cie para venda autom치tica
		check_surface_sale()
	
	stop_digging()

func check_surface_sale():
	var player_tile_pos = terrain_manager.world_to_tile_pos(global_position)
	
	# Se est치 na superf칤cie (y = 0 ou 1) e tem ouro, mostrar op칞칚o de venda
	if player_tile_pos.y <= 1 and game_manager.player_gold > 0:
		# Aqui voc칡 pode adicionar l칩gica para mostrar bot칚o de venda ou vender automaticamente
		if Input.is_action_just_pressed("sell"):  # Bot칚o separado para vender
			game_manager.sell_all_gold()

func _input(event):
	# Debug: mostrar posi칞칚o atual quando pressionar D
	if event.is_action_pressed("ui_right"):
		var player_tile_pos = terrain_manager.world_to_tile_pos(global_position)
		var tile_below = Vector2i(player_tile_pos.x, player_tile_pos.y + 1)
		var has_ground = terrain_manager.has_block_at(tile_below)
		print("Player em tile: ", player_tile_pos, " | Tile abaixo: ", tile_below, " | Tem ch칚o: ", has_ground, " | is_on_floor(): ", is_on_floor())
	
	# Abrir/fechar loja quando na superf칤cie
	if event.is_action_pressed("open_shop"):
		var player_tile_pos = terrain_manager.world_to_tile_pos(global_position)
		if player_tile_pos.y <= 1:  # Na superf칤cie
			game_manager.toggle_shop()
